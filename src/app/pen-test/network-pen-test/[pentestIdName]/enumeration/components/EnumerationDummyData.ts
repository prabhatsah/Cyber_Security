import {
  Enum4LinuxADResult,
  Enum4LinuxGenericResult,
  NetBIOSInfo,
  RpcSession,
} from "@/app/NetworkPentestType";

export const adServerWithCredResp = `ENUM4LINUX - next generation (v1.3.5)
 ==========================
|    Target Information    |
 ========================== 
[*] Target ........... 192.168.3.100
[*] Username ......... 'rizwanansari@Keross.local'
[*] Random Username .. 'vhkmoahm'
[*] Password ......... 'Keross@1234'
[*] Timeout .......... 5 second(s)
 
 ======================================
|    Listener Scan on 192.168.3.100    |
 ======================================
[*] Checking LDAP
[+] LDAP is accessible on 389/tcp
[*] Checking LDAPS
[+] LDAPS is accessible on 636/tcp
[*] Checking SMB
[+] SMB is accessible on 445/tcp
[*] Checking SMB over NetBIOS
[+] SMB over NetBIOS is accessible on 139/tcp

 =====================================================
|    Domain Information via LDAP for 192.168.3.100    |
 =====================================================
[*] Trying LDAP
[+] Appears to be root/parent DC
[+] Long domain name is: Keross.local
  
 ============================================================
|    NetBIOS Names and Workgroup/Domain for 192.168.3.100    |
 ============================================================
[+] Got domain/workgroup name: KEROSS
[+] Full NetBIOS names information:
- KEROSS-AD-SERVE <00> - B <ACTIVE> Workstation Service
- KEROSS <00> - <GROUP> B <ACTIVE> Domain/Workgroup Name
- KEROSS <1c> - <GROUP> B <ACTIVE> Domain Controllers
- KEROSS <1b> - B <ACTIVE> Domain Master Browser
- KEROSS-AD-SERVE <20> - B <ACTIVE> File Server Service
- MAC Address = 8C-EC-4B-AE-EB-7F
 
 ==========================================
|    SMB Dialect Check on 192.168.3.100    |
 ==========================================
[*] Trying on 445/tcp 
[+] Supported dialects and settings:
Supported dialects:
  SMB 1.0: false
  SMB 2.0.2: true
  SMB 2.1: true
  SMB 3.0: true
  SMB 3.1.1: true
Preferred dialect: SMB 3.0
SMB1 only: false
SMB signing required: true

 ============================================================
|    Domain Information via SMB session for 192.168.3.100    |
 ============================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found domain information via SMB
NetBIOS computer name: KEROSS-AD-SERVE
NetBIOS domain name:
KEROSS DNS domain: Keross.local
FQDN: KEROSS-AD-SERVER.Keross.local
Derived membership: domain member
Derived domain: KEROSS

 ==========================================
|    RPC Session Check on 192.168.3.100    |
 ==========================================
[*] Check for anonymous access (null session)
[+] Server allows authentication via username '' and password ''
[*] Check for password authentication
[+] Server allows authentication via username 'rizwanansari@Keross.local' and password 'Keross@1234'
[*] Check for guest access
[-] Could not establish guest session: STATUS_LOGON_FAILURE

 ====================================================
|    Domain Information via RPC for 192.168.3.100    |
 ====================================================
[+] Domain: KEROSS
[+] Domain SID: S-1-5-21-2008772436-1507277510-2029338615
[+] Membership: domain member

 ================================================
|    OS Information via RPC for 192.168.3.100    |
 ================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found OS information via SMB 
[*] Enumerating via 'srvinfo' 
[+] Found OS information via 'srvinfo' 
[+] After merging OS information we have the following result:
OS: Windows 10, Windows Server 2019, Windows Server 2016
OS version: '10.0'
OS release: ''
OS build: '26100'
Native OS: not supported
Native LAN manager: not supported
Platform id: '500'
Server type: '0x80102b'
Server type string: Wk Sv PDC Tim NT

 ======================================
|    Users via RPC on 192.168.3.100    |
 ======================================
[*] Enumerating users via 'querydispinfo'
[+] Found 15 user(s) via 'querydispinfo'
[*] Enumerating users via 'enumdomusers'
[+] Found 15 user(s) via 'enumdomusers'
[+] After merging user results we have 15 user(s) total:
'1101':
  username: sandipdhara
  name: Sandip Dhara
  acb: '0x00000010'
  description: (null)
'1103':
  username: saranikdey
  name: Saranik Dey
  acb: '0x00000010'
  description: (null)
'1107':
  username: Yogesh
  name: Yogesh
  acb: '0x00000010'
  description: (null)
'1108':
  username: Piyali Mondal
  name: Piyali Mondal
  acb: '0x00020010'
  description: (null)
'1110':
  username: Dia
  name: Dia Samajdar
  acb: '0x00020010'
  description: (null)
'1112':
  username: Sushmita Chakraborty
  name: Sushmita Chakraborty
  acb: '0x00000010'
  description: (null)
'1116':
  username: javedmondal
  name: javed mondal
  acb: '0x00000010'
  description: (null)
'1118':
  username: sauradipghosh
  name: sauradip ghosh
  acb: '0x00000010'
  description: (null)
'1119':
  username: sudipbhuniya
  name: Sudip Bhuniya
  acb: '0x00000010'
  description: (null)'
'1121':
  username: rizwanansari
  name: Rizwan Ansari
  acb: '0x00000010'
  description: (null)
'1124':
  username: sarbikmal
  name: Sarbik Mal
  acb: '0x00000010'
  description: (null)
'1127':
  username: rameshkumarprasad
  name: Ramesh Kumar Prasad
  acb: '0x00000010'
  description: (null)
'500':
  username: Administrator
  name: (null)
  acb: '0x00000210'
  description: Built-in account for administering the computer/domain
'501':
  username: Guest
  name: (null)
  acb: '0x00000215'
  description: Built-in account for guest access to the computer/domain
'502':
  username: krbtgt
  name: (null)
  acb: '0x00000011'
  description: Key Distribution Center Service Account

 =======================================
|    Groups via RPC on 192.168.3.100    |
 =======================================
[*] Enumerating local groups
[+] Found 7 group(s) via 'enumalsgroups domain'
[*] Enumerating builtin groups [+] Found 29 group(s) via 'enumalsgroups builtin'
[*] Enumerating domain groups
[+] Found 17 group(s) via 'enumdomgroups'
[+] After merging groups results we have 53 group(s) total:
'1104':
  groupname: DHCP Users
  type: local
'1105':
  groupname: DHCP Administrators
  type: local
'1113':
  groupname: DnsAdmins
  type: local
'1114':
  groupname: DnsUpdateProxy
  type: domain
'498':
  groupname: Enterprise Read-only Domain Controllers
  type: domain
'512':
  groupname: Domain Admins
  type: domain
'513':
  groupname: Domain Users
  type: domain
'514':
  groupname: Domain Guests
  type: domain
'515':
  groupname: Domain Computers
  type: domain
'516':
  groupname: Domain Controllers
  type: domain
'517':
  groupname: Cert Publishers
  type: local
'518':
  groupname: Schema Admins
  type: domain
'519':
  groupname: Enterprise Admins
  type: domain
'520':
  groupname: Group Policy Creator Owners
  type: domain
'521':
  groupname: Read-only Domain Controllers
  type: domain
'522':
  groupname: Cloneable Domain Controllers
  type: domain
'525':
  groupname: Protected Users
  type: domain
'526':
  groupname: Key Admins
  type: domain
'527':
  groupname: Enterprise Key Admins
  type: domain
'528':
  groupname: Forest Trust Accounts
  type: domain
'529':
  groupname: External Trust Accounts
  type: domain
'544':
  groupname: Administrators
  type: builtin
'545':
  groupname: Users
  type: builtin
'546':
  groupname: Guests
  type: builtin
'548':
  groupname: Account Operators
  type: builtin
'549':
  groupname: Server Operators
  type: builtin
'550':
  groupname: Print Operators
  type: builtin
'551':
  groupname: Backup Operators
  type: builtin
'552':
  groupname: Replicator
  type: builtin
'553':
  groupname: RAS and IAS Servers
  type: local
'554':
  groupname: Pre-Windows 2000 Compatible Access
  type: builtin
'555':
  groupname: Remote Desktop Users
  type: builtin
'556':
  groupname: Network Configuration Operators
  type: builtin
'557':
  groupname: Incoming Forest Trust Builders
  type: builtin
'558':
  groupname: Performance Monitor Users
  type: builtin
'559':
  groupname: Performance Log Users
  type: builtin
'560':
  groupname: Windows Authorization Access Group
  type: builtin
'561':
  groupname: Terminal Server License Servers
  type: builtin
'562':
  groupname: Distributed COM Users
  type: builtin
'568':
  groupname: IIS_IUSRS
  type: builtin
'569':
  groupname: Cryptographic Operators
  type: builtin
'571':
  groupname: Allowed RODC Password Replication Group
  type: local
'572':
  groupname: Denied RODC Password Replication Group
  type: local
'573':
  groupname: Event Log Readers
  type: builtin
'574':
  groupname: Certificate Service DCOM Access
  type: builtin
'575':
  groupname: RDS Remote Access Servers
  type: builtin
'576':
  groupname: RDS Endpoint Servers
  type: builtin
'577':
  groupname: RDS Management Servers
  type: builtin
'578':
  groupname: Hyper-V Administrators
  type: builtin
'579':
  groupname: Access Control Assistance Operators
  type: builtin
'580':
  groupname: Remote Management Users
  type: builtin
'582':
  groupname: Storage Replica Administrators
  type: builtin
'585':
  groupname: OpenSSH Users
  type: builtin

 =======================================
|    Shares via RPC on 192.168.3.100    |
 =======================================
[*] Enumerating shares
[+] Found 8 share(s):
ADMIN$:
  comment: Remote Admin
  type: Disk
BKP:
  comment: ''
  type: Disk
C$:
  comment: Default share
  type: Disk
D$:
  comment: Default share
  type: Disk
IPC$:
  comment: Remote IPC
  type: IPC
JPG:
  comment: ''
  type: Disk
NETLOGON:
  comment: Logon server share
  type: Disk
SYSVOL:
  comment: Logon server share
  type: Disk
[*] Testing share ADMIN$
[+] Mapping: DENIED, Listing: N/A
[*] Testing share BKP
[+] Mapping: OK, Listing: OK
[*] Testing share C$
[+] Mapping: DENIED, Listing: N/A
[*] Testing share D$
[+] Mapping: DENIED, Listing: N/A
[*] Testing share IPC$
[+] Mapping: OK, Listing: NOT SUPPORTED
[*] Testing share JPG
[+] Mapping: OK, Listing: OK
[*] Testing share NETLOGON
[+] Mapping: OK, Listing: OK
[*] Testing share SYSVOL
[+] Mapping: OK, Listing: OK

 ==========================================
|    Policies via RPC for 192.168.3.100    |
 ==========================================
[*] Trying port 445/tcp
[-] SMB connection error on port 445/tcp: session failed
[*] Trying port 139/tcp
[-] SMB connection error on port 139/tcp: session failed

 ==========================================
|    Printers via RPC for 192.168.3.100    |
 ==========================================
[+] No printers available Completed after 6.15 seconds`;

export const adServerWithoutCredResp = `ENUM4LINUX - next generation (v1.3.5)
 ==========================
|    Target Information    |
 ==========================
[*] Target ........... 192.168.3.169
[*] Username ......... ''
[*] Random Username .. 'movpfetk'
[*] Password ......... ''
[*] Timeout .......... 5 second(s)

 ======================================
|    Listener Scan on 192.168.3.169    |
 ======================================
[*] Checking LDAP
[-] Could not connect to LDAP on 389/tcp: connection refused
[*] Checking LDAPS
[-] Could not connect to LDAPS on 636/tcp: connection refused
[*] Checking SMB
[+] SMB is accessible on 445/tcp
[*] Checking SMB over NetBIOS
[+] SMB over NetBIOS is accessible on 139/tcp

 ============================================================
|    NetBIOS Names and Workgroup/Domain for 192.168.3.169    |
 ============================================================
[+] Got domain/workgroup name: KEROSS
[+] Full NetBIOS names information:
- KER-LPTP-09     <20> -         M <ACTIVE>  File Server Service                                              
- KEROSS          <00> - <GROUP> M <ACTIVE>  Domain/Workgroup Name                                            
- KER-LPTP-09     <00> -         M <ACTIVE>  Workstation Service                                              
- MAC Address = F0-2F-74-46-74-64                                                                             

 ==========================================
|    SMB Dialect Check on 192.168.3.169    |
 ==========================================
[*] Trying on 445/tcp
[+] Supported dialects and settings:
Supported dialects:                                                                                           
  SMB 1.0: false                                                                                              
  SMB 2.0.2: true                                                                                             
  SMB 2.1: true                                                                                               
  SMB 3.0: true                                                                                               
  SMB 3.1.1: true                                                                                             
Preferred dialect: SMB 3.0                                                                                    
SMB1 only: false                                                                                              
SMB signing required: true                                                                                    

 ============================================================
|    Domain Information via SMB session for 192.168.3.169    |
 ============================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found domain information via SMB
NetBIOS computer name: KER-LPTP-09                                                                            
NetBIOS domain name: KEROSS                                                                                   
DNS domain: Keross.local                                                                                      
FQDN: KER-LPTP-09.Keross.local                                                                                
Derived membership: domain member                                                                             
Derived domain: KEROSS                                                                                        

 ==========================================
|    RPC Session Check on 192.168.3.169    |
 ==========================================
[*] Check for anonymous access (null session)
[-] Could not establish null session: STATUS_ACCESS_DENIED
[*] Check for guest access
[-] Could not establish guest session: STATUS_LOGON_FAILURE
[-] Sessions failed, neither null nor user sessions were possible

 ================================================
|    OS Information via RPC for 192.168.3.169    |
 ================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found OS information via SMB
[*] Enumerating via 'srvinfo'
[-] Skipping 'srvinfo' run, not possible with provided credentials
[+] After merging OS information we have the following result:
OS: Windows 10, Windows Server 2019, Windows Server 2016                                                      
OS version: '10.0'                                                                                            
OS release: ''                                                                                                
OS build: '26100'                                                                                             
Native OS: not supported                                                                                      
Native LAN manager: not supported                                                                             
Platform id: null                                                                                             
Server type: null                                                                                             
Server type string: null                                                                                      

[!] Aborting remainder of tests since sessions failed, rerun with valid credentials

Completed after 2.32 seconds`;

export const nonAdServerResp = `ENUM4LINUX - next generation (v1.3.5)
 ==========================
|    Target Information    |
 ==========================
[*] Target ........... 192.168.3.167
[*] Username ......... ''
[*] Random Username .. 'bttklssf'
[*] Password ......... ''
[*] Timeout .......... 5 second(s)

 ======================================
|    Listener Scan on 192.168.3.167    |
 ======================================
[*] Checking LDAP
[-] Could not connect to LDAP on 389/tcp: connection refused
[*] Checking LDAPS
[-] Could not connect to LDAPS on 636/tcp: connection refused
[*] Checking SMB
[+] SMB is accessible on 445/tcp
[*] Checking SMB over NetBIOS
[+] SMB over NetBIOS is accessible on 139/tcp

 ============================================================
|    NetBIOS Names and Workgroup/Domain for 192.168.3.167    |
 ============================================================
[+] Got domain/workgroup name: WORK
[+] Full NetBIOS names information:
- KER-LPTP-51     <20> -         B <ACTIVE>  File Server Service                                                                                              
- WORK            <00> - <GROUP> B <ACTIVE>  Domain/Workgroup Name                                                                                            
- KER-LPTP-51     <00> -         B <ACTIVE>  Workstation Service                                                                                              
- MAC Address = 58-11-22-E7-90-07                                                                                                                             

 ==========================================
|    SMB Dialect Check on 192.168.3.167    |
 ==========================================
[*] Trying on 445/tcp
[+] Supported dialects and settings:
Supported dialects:                                                                                                                                           
  SMB 1.0: false                                                                                                                                              
  SMB 2.0.2: true                                                                                                                                             
  SMB 2.1: true                                                                                                                                               
  SMB 3.0: true                                                                                                                                               
  SMB 3.1.1: true                                                                                                                                             
Preferred dialect: SMB 3.0                                                                                                                                    
SMB1 only: false                                                                                                                                              
SMB signing required: true                                                                                                                                    

 ============================================================
|    Domain Information via SMB session for 192.168.3.167    |
 ============================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found domain information via SMB
NetBIOS computer name: KER-LPTP-51                                                                                                                            
NetBIOS domain name: ''                                                                                                                                       
DNS domain: KER-LPTP-51                                                                                                                                       
FQDN: KER-LPTP-51                                                                                                                                             
Derived membership: workgroup member                                                                                                                          
Derived domain: unknown                                                                                                                                       

 ==========================================
|    RPC Session Check on 192.168.3.167    |
 ==========================================
[*] Check for anonymous access (null session)
[-] Could not establish null session: STATUS_ACCESS_DENIED
[*] Check for guest access
[-] Could not establish guest session: STATUS_LOGON_FAILURE
[-] Sessions failed, neither null nor user sessions were possible

 ================================================
|    OS Information via RPC for 192.168.3.167    |
 ================================================
[*] Enumerating via unauthenticated SMB session on 445/tcp
[+] Found OS information via SMB
[*] Enumerating via 'srvinfo'
[-] Skipping 'srvinfo' run, not possible with provided credentials
[+] After merging OS information we have the following result:
OS: Windows 10, Windows Server 2019, Windows Server 2016                                                                                                      
OS version: '10.0'                                                                                                                                            
OS release: ''                                                                                                                                                
OS build: '26100'                                                                                                                                             
Native OS: not supported                                                                                                                                      
Native LAN manager: not supported                                                                                                                             
Platform id: null                                                                                                                                             
Server type: null                                                                                                                                             
Server type string: null                                                                                                                                      

[!] Aborting remainder of tests since sessions failed, rerun with valid credentials

Completed after 2.32 seconds`;

export function parseEnum4LinuxGeneric(
  output: string
): Enum4LinuxGenericResult {
  const result: Enum4LinuxGenericResult = {
    services: {
      ldap:
        output.includes("Checking LDAP") &&
        !output.includes("Could not connect to LDAP"),
      ldaps:
        output.includes("Checking LDAPS") &&
        !output.includes("Could not connect to LDAPS"),
      smb445: output.includes("[+] SMB is accessible on 445/tcp"),
      smb139: output.includes("[+] SMB over NetBIOS is accessible on 139/tcp"),
    },
  };

  // Target
  const targetMatch = output.match(/\[\*\] Target\s+\.*\s(.+)/);
  if (targetMatch) result.target = targetMatch[1].trim();

  // Workgroup / Domain
  const workgroupMatch = output.match(/Got domain\/workgroup name: (.+)/);
  if (workgroupMatch) result.workgroupOrDomain = workgroupMatch[1].trim();

  // NetBIOS Names (structured)
  const netbiosRegex =
    /-\s+([A-Z0-9\-\_]+)\s+<(\w+)> -\s*(<GROUP>)?\s*([BM])\s*<ACTIVE>\s+(.+)/g;
  const netbiosMatches: NetBIOSInfo[] = [];
  let nm;
  while ((nm = netbiosRegex.exec(output)) !== null) {
    netbiosMatches.push({
      name: nm[1].trim(),
      hex: nm[2],
      group: nm[3] === "<GROUP>",
      active: true,
      type: nm[5].trim(),
    });
  }
  if (netbiosMatches.length) result.netbiosNames = netbiosMatches;

  // NetBIOS computer & domain names from SMB session
  const nbComputer = output.match(/NetBIOS computer name:\s+(.+)/);
  if (nbComputer) result.netbiosComputerName = nbComputer[1].trim();

  const nbDomain = output.match(/NetBIOS domain name:\s+(.+)/);
  if (nbDomain) result.netbiosDomainName = nbDomain[1].trim();

  // MAC Address
  const macMatch = output.match(/MAC Address = (.+)/);
  if (macMatch) result.macAddress = macMatch[1].trim();

  // SMB Dialects (structured)
  const smbDialects: Record<string, boolean> = {};
  const dialectRegex = /SMB\s([\d\.]+):\s(true|false)/g;
  let dm;
  while ((dm = dialectRegex.exec(output)) !== null) {
    smbDialects[`SMB ${dm[1]}`] = dm[2] === "true";
  }
  if (Object.keys(smbDialects).length > 0) {
    const preferredMatch = output.match(/Preferred dialect:\s+(.+)/);
    const smb1OnlyMatch = output.match(/SMB1 only:\s+(true|false)/);
    const smbSigningMatch = output.match(
      /SMB signing required:\s+(true|false)/
    );
    result.smbDialects = {
      versions: smbDialects,
      preferredDialect: preferredMatch?.[1].trim() || null,
      smb1Only: smb1OnlyMatch ? smb1OnlyMatch[1] === "true" : null,
      smbSigningRequired: smbSigningMatch
        ? smbSigningMatch[1] === "true"
        : null,
    };
  }

  // Domain Info
  const fqdnMatch = output.match(/FQDN: (.+)/);
  if (fqdnMatch) result.fqdn = fqdnMatch[1].trim();

  const dnsDomainMatch = output.match(/DNS domain: (.+)/);
  if (dnsDomainMatch) result.dnsDomain = dnsDomainMatch[1].trim();

  // RPC Session Check
  if (output.includes("RPC Session Check")) {
    const rpcSession: RpcSession = {
      nullSession: null,
      authenticatedSession: null,
      guestSession: null,
    };

    // Match all "Server allows authentication via username ... and password ..."
    const authRegex =
      /\[\+\] Server allows authentication via username '([^']*)' and password '([^']*)'/g;
    let match;
    while ((match = authRegex.exec(output)) !== null) {
      const username = match[1];
      const password = match[2];

      if (username === "" && password === "") {
        rpcSession.nullSession = { username, password };
      } else {
        rpcSession.authenticatedSession = { username, password };
      }
    }

    // Guest session check
    if (/Server allows authentication via username 'guest'?/i.test(output)) {
      rpcSession.guestSession = { username: "guest", password: "" };
    } else if (/Could not establish guest session/i.test(output)) {
      rpcSession.guestSession = null;
    }

    result.rpcSessions = rpcSession;
  }

  // OS Information via RPC
  const os = output.match(/OS: (.+)/)?.[1].trim() || null;
  const version = output.match(/OS version: '(.+)'/)?.[1] || null;
  const release = output.match(/OS release: '(.+)'/)?.[1] || null;
  const build = output.match(/OS build: '(.+)'/)?.[1] || null;
  const nativeOs = output.match(/Native OS: (.+)/)?.[1].trim() || null;
  const nativeLan =
    output.match(/Native LAN manager: (.+)/)?.[1].trim() || null;
  const platformId = output.match(/Platform id: '(.+)'/)?.[1] || null;
  const serverType = output.match(/Server type: '(.+)'/)?.[1] || null;
  const serverTypeStr =
    output.match(/Server type string: (.+)/)?.[1].trim() || null;

  result.osInfo = {
    os,
    version,
    release,
    build,
    nativeOs,
    nativeLanManager: nativeLan,
    platformId,
    serverType,
    serverTypeString: serverTypeStr,
  };

  return result;
}

export function parseEnum4LinuxAD(output: string): Enum4LinuxADResult {
  // start with generic result
  const base = parseEnum4LinuxGeneric(output);

  const result: Enum4LinuxADResult = {
    ...base,
    users: [],
    groups: [],
    shares: [],
    printers: [],
  };

  // Domain Info via LDAP
  if (output.includes("Domain Information via LDAP")) {
    result.ldapDomainInfo = {
      rootDc: output.includes("Appears to be root/parent DC"),
    };
    const longDomainMatch = output.match(/Long domain name is: (.+)/);
    if (longDomainMatch) {
      result.ldapDomainInfo.longDomainName = longDomainMatch[1].trim();
    }
  }

  // Domain Info via RPC
  const domainMatch = output.match(/\[\+\] Domain: (.+)/);
  const sidMatch = output.match(/\[\+\] Domain SID: (.+)/);
  const membershipMatch = output.match(/\[\+\] Membership: (.+)/);

  if (domainMatch || sidMatch || membershipMatch) {
    result.rpcDomainInfo = {
      domain: domainMatch?.[1].trim(),
      sid: sidMatch?.[1].trim(),
      membership: membershipMatch?.[1].trim(),
    };
  }

  // Users
  const userRegex =
    /'(\d+)':\s+username: (.+)\s+name: (.+)\s+acb: '(.+)'\s+description: (.+)/g;
  let userMatch;
  while ((userMatch = userRegex.exec(output)) !== null) {
    result.users.push({
      id: userMatch[1],
      username: userMatch[2].trim(),
      name: userMatch[3].trim() === "(null)" ? null : userMatch[3].trim(),
      acb: userMatch[4],
      description:
        userMatch[5].trim() === "(null)" ? null : userMatch[5].trim(),
    });
  }

  // Groups
  const groupRegex = /'(\d+)':\s+groupname: (.+)\s+type: (.+)/g;
  let groupMatch;
  while ((groupMatch = groupRegex.exec(output)) !== null) {
    result.groups.push({
      id: groupMatch[1],
      groupname: groupMatch[2].trim(),
      type: groupMatch[3].trim(),
    });
  }

  // Shares
  const shareRegex =
    /(\w+):\s+comment: (.*)\s+type: (.+)(?:\s+\[\+\] Mapping: (.+), Listing: (.+))?/g;
  let shareMatch;
  while ((shareMatch = shareRegex.exec(output)) !== null) {
    result.shares.push({
      name: shareMatch[1],
      comment: shareMatch[2].trim(),
      type: shareMatch[3].trim(),
      mapping: shareMatch[4]?.trim() || "UNKNOWN",
      listing: shareMatch[5]?.trim() || "UNKNOWN",
    });
  }

  // --- Policies ---
  const outputLines = output.split("\n");

  const smbConnections: Record<string, boolean> = {};
  outputLines.forEach((line) => {
    const portMatch = line.match(/Trying port (\d+)\/tcp/);
    if (portMatch) {
      const port: string = portMatch[1];
      const successMatch = outputLines.find(
        (l) => l.includes(`port ${port}/tcp`) && l.includes("session failed")
      );
      smbConnections[port] = !successMatch;
    }
  });

  result.policies = { smbConnections };

  // Printers
  if (output.includes("Printers via RPC")) {
    if (!output.includes("No printers available")) {
      const printerMatches = [...output.matchAll(/\[\+\] (.+)/g)].map((m) =>
        m[1].trim()
      );
      result.printers = printerMatches.map((p) => ({ name: p }));
    } else {
      result.printers = [];
    }
  }

  return result;
}

// export function parseEnum4LinuxAD(output: string): Enum4LinuxADResult {
//   const result: Enum4LinuxADResult = {
//     domain: null,
//     domainSid: null,
//     fqdn: null,
//     dnsDomain: null,
//     os: null,
//     osBuild: null,
//     users: [],
//     groups: [],
//     shares: [],
//   };

//   // Domain Info
//   const domainMatch = output.match(/\[\+\] Domain: (.+)/);
//   const sidMatch = output.match(/\[\+\] Domain SID: (.+)/);
//   const fqdnMatch = output.match(/FQDN: (.+)/);
//   const dnsDomainMatch = output.match(/DNS domain: (.+)/);

//   result.domain = domainMatch?.[1].trim() || null;
//   result.domainSid = sidMatch?.[1].trim() || null;
//   result.fqdn = fqdnMatch?.[1].trim() || null;
//   result.dnsDomain = dnsDomainMatch?.[1].trim() || null;

//   // OS Info
//   const osMatch = output.match(/OS: (.+)/);
//   const osBuildMatch = output.match(/OS build: '(.+)'/);

//   result.os = osMatch?.[1].trim() || null;
//   result.osBuild = osBuildMatch?.[1].trim() || null;

//   // Users
//   const userRegex =
//     /'(\d+)':\s+username: (.+)\s+name: (.+)\s+acb: '(.+)'\s+description: (.+)/g;
//   let userMatch;
//   while ((userMatch = userRegex.exec(output)) !== null) {
//     result.users.push({
//       id: userMatch[1],
//       username: userMatch[2].trim(),
//       name: userMatch[3].trim() === "(null)" ? null : userMatch[3].trim(),
//       acb: userMatch[4],
//       description:
//         userMatch[5].trim() === "(null)" ? null : userMatch[5].trim(),
//     });
//   }

//   // Groups
//   const groupRegex = /'(\d+)':\s+groupname: (.+)\s+type: (.+)/g;
//   let groupMatch;
//   while ((groupMatch = groupRegex.exec(output)) !== null) {
//     result.groups.push({
//       id: groupMatch[1],
//       groupname: groupMatch[2].trim(),
//       type: groupMatch[3].trim(),
//     });
//   }

//   // Shares
//   const shareRegex =
//     /(\w+):\s+comment: (.*)\s+type: (.+)(?:\s+\[\+\] Mapping: (.+), Listing: (.+))?/g;
//   let shareMatch;
//   while ((shareMatch = shareRegex.exec(output)) !== null) {
//     result.shares.push({
//       name: shareMatch[1],
//       comment: shareMatch[2].trim(),
//       type: shareMatch[3].trim(),
//       mapping: shareMatch[4]?.trim() || "UNKNOWN",
//       listing: shareMatch[5]?.trim() || "UNKNOWN",
//     });
//   }

//   return result;
// }
