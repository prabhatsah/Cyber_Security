"use client";

import { useEffect } from "react";
import { usePentestContext } from "../../../components/PentestContext";
import GlobalLoader from "@/components/GlobalLoader";
import { Globe, Mail, Server } from "lucide-react";
import SubDomainsOverview from "./components/SubDomainsOverview";
import { Card, Title } from "@tremor/react";
import SubDomainsTableCommonTemplate from "./components/SubDomainsTableCommonTemplate";
import NetworksTable from "./components/NetworkTable";
import { redirect } from "next/navigation";

interface ScanDataToBeDisplayedType {
  name: string;
  cname: string;
  ipv4: {
    address?: string;
    network?: string;
  },
  ipv6: {
    address?: string;
    network?: string;
  }
}

interface Network {
  networkId: string;
  asn: string;
  managedby: string;
}

export default function SubDomainsMainTemplate({ pentestIdName }: { pentestIdName: string; }) {
  const [pentestId, pentestNameInUrl] = pentestIdName.split("_");
  const pentestName = pentestNameInUrl.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  const { pentestData, loading, error, setPentestId } = usePentestContext();

  useEffect(() => {
    if (typeof pentestId === 'string') {
      setPentestId(pentestId);
    }
  }, [pentestId]);

  if (error) return <div>{error}</div>;
  if (!pentestData && !loading) return <div></div>;
  if (loading || !pentestData) return <GlobalLoader />;

  console.log("Pen Test Data: ", pentestData);
  const amassData: Array<string> = pentestData.reconnaissance && pentestData.reconnaissance.activeReconnaissance ?
    [...pentestData.reconnaissance.activeReconnaissance.amassData] : [];


  let subdomains: Array<string> = [], nameServers: Array<string> = [], mailServers: Array<string> = [], ipv4: Record<string, string> = {}, ipv6: Record<string, string> = {},
    cnames: Record<string, string> = {}, asnmanagedby: Record<string, string> = {}, networkasn: Record<string, string> = {}, ipMap: Record<string, string> = {};

  amassData.forEach((entry) => {
    const fqdnMatch = entry.match(
      /^(.+?) \(FQDN\) --> (.+?) --> (.+?) \(([^)]+)\)$/
    );
    if (fqdnMatch) {
      const source = fqdnMatch[1].trim();
      const relation = fqdnMatch[2].trim();
      const target = fqdnMatch[3].trim();
      // const targetType = fqdnMatch[4].trim(); // Unused here

      switch (relation) {
        case "node":
          subdomains.push(target);
          break;
        case "ns_record":
          nameServers.push(target);
          break;
        case "mx_record":
          mailServers.push(target);
          break;
        case "a_record":
          ipv4[source] = target;
          break;
        case "aaaa_record":
          ipv6[source] = target;
          break;
        case "cname_record":
          cnames[source] = target;
          break;
        default:
          break;
      }
    }

    const asnmatch = entry.match(/^(.+?) \(ASN\) --> (.+?) --> (.+?) \(([^)]+)\)$/);
    if (asnmatch) {
      const relation = asnmatch[2];
      switch (relation) {
        case "announces":
          networkasn[asnmatch[3]] = asnmatch[1];
          break;
        case "managed_by":
          asnmanagedby[asnmatch[1]] = asnmatch[3] + " - " + asnmatch[4];
          break;
        default:
          break;
      }
    }

    const netblockMatch = entry.match(
      /^(.+?) \(([^)]+)\) --> contains --> (.+?) \(([^)]+)\)$/
    );
    if (netblockMatch) {
      const networkId = netblockMatch[1].trim();
      const ipAddress = netblockMatch[3].trim();
      ipMap[ipAddress] = networkId;
    }
  });

  const displayData: {
    mailServers: ScanDataToBeDisplayedType[],
    nameServers: ScanDataToBeDisplayedType[],
    subdomains: ScanDataToBeDisplayedType[],
  } = {
    mailServers: [],
    nameServers: [],
    subdomains: []
  }

  mailServers.forEach((item) => {
    displayData.mailServers.push({
      name: item,
      cname: cnames[item] ? cnames[item] : "N/A",
      ipv4: {
        address: ipv4[item]
          ? ipv4[item]
          : cnames[item]
            ? ipv4[cnames[item]]
            : undefined,
        network: ipMap[ipv4[item]],
      },
      ipv6: {
        address: ipv6[item]
          ? ipv6[item]
          : cnames[item]
            ? ipv6[cnames[item]]
            : undefined,
        network: ipMap[ipv6[item]],
      },
    });
  });

  nameServers.forEach((item) => {
    displayData.nameServers.push({
      name: item,
      cname: cnames[item] ? cnames[item] : "N/A",
      ipv4: {
        address: ipv4[item]
          ? ipv4[item]
          : cnames[item]
            ? ipv4[cnames[item]]
            : undefined,
        network: ipMap[ipv4[item]],
      },
      ipv6: {
        address: ipv6[item]
          ? ipv6[item]
          : cnames[item]
            ? ipv6[cnames[item]]
            : undefined,
        network: ipMap[ipv6[item]],
      },
    });
  });

  subdomains.forEach((item) => {
    displayData.subdomains.push({
      name: item,
      cname: cnames[item] ? cnames[item] : "N/A",
      ipv4: {
        address: ipv4[item]
          ? ipv4[item]
          : cnames[item]
            ? ipv4[cnames[item]]
            : undefined,
        network: ipMap[ipv4[item]],
      },
      ipv6: {
        address: ipv6[item]
          ? ipv6[item]
          : cnames[item]
            ? ipv6[cnames[item]]
            : undefined,
        network: ipMap[ipv6[item]],
      },
    });
  });


  let networkdata: Network[] = [];
  for (let key in networkasn) {
    networkdata.push({
      networkId: key,
      asn: networkasn[key],
      managedby: asnmanagedby[networkasn[key]],
    });
  }

  const subDomainOverviewData = [
    {
      title: "Total Subdomains Discovered",
      value: subdomains.length,
      Icon: Globe
    },
    {
      title: "Mail Servers Found",
      value: mailServers.length,
      Icon: Mail
    },
    {
      title: "Name Servers Identified",
      value: nameServers.length,
      Icon: Server
    }
  ];

  return (
    <>
      {pentestData.reconnaissance && pentestData.reconnaissance.activeReconnaissance ? (
        <div className="flex flex-col gap-3 mb-3">
          <SubDomainsOverview subDomainOverviewData={subDomainOverviewData} />
          <Card className="flex flex-col gap-3 p-4 rounded-md">
            <Title className="font-bold text-widget-title text-widgetHeader">Name Servers</Title>
            <SubDomainsTableCommonTemplate tableData={displayData.nameServers} />
          </Card>
          <Card className="flex flex-col gap-3 p-4 rounded-md">
            <Title className="font-bold text-widget-title text-widgetHeader">Mail Servers</Title>
            <SubDomainsTableCommonTemplate tableData={displayData.mailServers} />
          </Card>
          <Card className="flex flex-col gap-3 p-4 rounded-md">
            <Title className="font-bold text-widget-title text-widgetHeader">Subdomains</Title>
            <SubDomainsTableCommonTemplate tableData={displayData.subdomains} />
          </Card>
          <Card className="flex flex-col gap-3 p-4 rounded-md">
            <Title className="font-bold text-widget-title text-widgetHeader">Networks</Title>
            <NetworksTable networks={networkdata} />
          </Card>
        </div>
      ) : redirect(`/pen-test/web-app-pen-test/${pentestIdName}/reconnaissance/active-reconnaissance/overview`)
      }
    </>
  )
}