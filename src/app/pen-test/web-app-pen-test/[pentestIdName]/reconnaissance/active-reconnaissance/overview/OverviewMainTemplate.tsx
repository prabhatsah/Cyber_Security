"use client";

import GlobalLoader from "@/components/GlobalLoader";
import { usePentestContext } from "../../../components/PentestContext";
import { useEffect } from "react";
import OverviewTopWidget from "./components/OverviewTopWidget";
import { Card, Title } from "@tremor/react";
import { BasicInfoWidget } from "@/components/BasicInfoWidget";
import TopFiveCriticalDataWidget from "./components/TopFiveCriticalDataWidget";
import { Cpu, EthernetPort, Network } from "lucide-react";
import { BasicInfoWidgetData, ParsedWhatWebData } from "../components/type";


export default function OverviewMainTemplate({ pentestIdName }: { pentestIdName: string; }) {
    const [pentestId, pentestNameInUrl] = pentestIdName.split("_");
    const pentestName = pentestNameInUrl.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    const { pentestData, loading, error, setPentestId } = usePentestContext();

    useEffect(() => {
        if (typeof pentestId === 'string') {
            setPentestId(pentestId);
        }
    }, [pentestId]);

    if (error) return <div>{error}</div>;
    if (!pentestData && !loading) return <div></div>;
    if (loading || !pentestData) return <GlobalLoader />;

    const nmap: string = pentestData?.scanData.nmap ?? "";
    const whatWeb: string = pentestData?.scanData.whatweb ?? "";
    const amass: Array<string> = pentestData?.scanData.amass ? pentestData?.scanData.amass.split("\n") : [];

    const parseWhatWebOutput = (whatWebOutput: string): ParsedWhatWebData[] => {
        const sections = whatWebOutput.split(/WhatWeb report for /).filter(Boolean);
        const results: ParsedWhatWebData[] = [];

        sections.forEach(section => {
            const lines = section.split('\n');
            let result: ParsedWhatWebData = {
                country: "N/A",
                headers: [],
                ip: "N/A,",
                plugins: [],
                status: "N/A",
                summary: "N/A",
                title: "N/A",
                url: "N/A",
            };

            // URL
            result.url = lines[0].trim();

            // Key-value fields (Status, Title, IP, Country)
            lines.forEach(line => {
                if (line.startsWith('Status')) result.status = line.split(':')[1]?.trim();
                if (line.startsWith('Title')) result.title = line.split(':')[1]?.trim();
                if (line.startsWith('IP')) result.ip = line.split(':')[1]?.trim();
                if (line.startsWith('Country')) result.country = line.split(':')[1]?.trim();
                if (line.startsWith('Summary')) result.summary = line.split(':')[1]?.trim();
            });

            // Detected plugins
            const pluginSection = section.match(/Detected Plugins:\n([\s\S]*?)\nHTTP Headers:/);
            if (pluginSection) {
                const pluginsRaw = pluginSection[1];
                const pluginNames = [...pluginsRaw.matchAll(/\[ ([^\]]+) \]/g)].map(m => m[1]);
                result.plugins = pluginNames;
            }

            // HTTP headers
            const headersMatch = section.match(/HTTP Headers:\n([\s\S]*?)\nhttps?:\/\//);
            if (headersMatch) {
                const rawHeaders = headersMatch[1].trim().split('\n').map(line => line.trim());
                result.headers = rawHeaders;
            }

            results.push(result);
        });

        return results;
    }
    const whatWebOutput = whatWeb.replace(/\u001b\[[0-9;]*m/g, '');
    const parsedWhatWebData: ParsedWhatWebData[] = parseWhatWebOutput(whatWebOutput);

    const parseNmapOutput = (nmapOutput: string) => {
        const lines = nmapOutput.trim().split('\n');
        const result: {
            target: string | null;
            ip: string | null;
            scanTime: string | null;
            hostStatus: string | null;
            latency: string | null;
            filteredPorts: number | null;
            openPorts: Array<{
                port: number;
                state: string;
                service: string;
                protocol: string;
                product: string;
                version: string;
            }>;
        } = {
            target: null,
            ip: null,
            scanTime: null,
            hostStatus: null,
            latency: null,
            filteredPorts: null,
            openPorts: []
        };

        for (const line of lines) {
            if (line.startsWith("Starting Nmap")) {
                const match = line.match(/Starting Nmap .* at (.+)/);
                if (match) result.scanTime = match[1].trim();
            }

            if (line.startsWith("Nmap scan report for")) {
                const match = line.match(/Nmap scan report for (.+) \(([\d.]+)\)/);
                if (match) {
                    result.target = match[1];
                    result.ip = match[2];
                }
            }

            if (line.includes("Host is up")) {
                const match = line.match(/Host is up \(([\d.s]+) latency\)/);
                result.hostStatus = "up";
                result.latency = match ? match[1] : null;
            }

            if (line.includes("filtered tcp ports")) {
                const match = line.match(/Not shown: (\d+) filtered tcp ports/);
                result.filteredPorts = match ? parseInt(match[1], 10) : null;
            }

            // const portMatch = line.match(/^(\d+)\/tcp\s+(\w+)\s+(\w+)/);
            const portMatch = line.match(/^(\d+)\/(tcp)\s+(\w+)\s+([^\s]+)(\s+.+)?/);
            if (portMatch) {
                const port = parseInt(portMatch[1], 10);
                const protocol = portMatch[2];
                const state = portMatch[3];
                const service = portMatch[4];
                const productVersionString = portMatch[5]?.trim() || "";

                let product = "N/A";
                let version = "N/A";

                if (productVersionString) {
                    const split = productVersionString.split(/\s+/, 2);
                    product = split[0] || "N/A";
                    version = split[1] ? productVersionString.slice(product.length + 1) : "N/A";
                }

                result.openPorts.push({
                    port,
                    state,
                    service,
                    protocol,
                    product,
                    version
                });

                // result.openPorts.push({
                //     port: parseInt(portMatch[1], 10),
                //     state: portMatch[2],
                //     service: portMatch[3]
                // });
            }
        }

        return result;
    }
    const parsedNmapData = parseNmapOutput(nmap);

    let subdomains: Array<string> = [];
    amass.forEach((entry) => {
        const fqdnMatch = entry.match(
            /^(.+?) \(FQDN\) --> (.+?) --> (.+?) \(([^)]+)\)$/
        );
        if (fqdnMatch) {
            const relation = fqdnMatch[2].trim();
            const target = fqdnMatch[3].trim();

            if (relation === "node") subdomains.push(target);
        }
    });


    const whatWebData = parsedWhatWebData[parsedWhatWebData.length - 1];

    const basicInfoWidgetData: BasicInfoWidgetData[] = [
        {
            name: "URL/Domain",
            value: whatWebData.url,
        },
        {
            name: "Title",
            value: whatWebData.title,
        },
        {
            name: "IP Address",
            value: whatWebData.ip,
        },
        {
            name: "Status",
            value: whatWebData.status,
        },
        {
            name: "Country",
            value: whatWebData.country,
        }
    ];

    const technologies = whatWebData.summary.split(", ");
    const overviewTopWidgetData = [
        {
            title: "Sub Domains Discovered",
            value: subdomains.length,
            Icon: Network
        },
        {
            title: "Open Ports Discovered",
            value: parsedNmapData.openPorts.length,
            Icon: EthernetPort
        },
        {
            title: "Technologies Identified",
            value: technologies.length,
            Icon: Cpu
        }
    ];

    const ports = parsedNmapData.openPorts.map(eachPorts => eachPorts.port.toString());

    return (
        <>
            <div className="flex flex-col gap-3">
                <OverviewTopWidget overviewTopWidgetData={overviewTopWidgetData} />
                <Card className="flex flex-col gap-3 p-4 rounded-md">
                    <Title className="font-bold text-widget-title text-widgetHeader">Basic Information</Title>
                    <BasicInfoWidget items={basicInfoWidgetData} columns={3} useDefault={false} />
                </Card>
                <TopFiveCriticalDataWidget subDomains={subdomains} ports={ports} technologies={technologies} />
            </div>
        </>
    )
}