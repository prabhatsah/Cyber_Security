"use client";

import GlobalLoader from "@/components/GlobalLoader";
import { usePentestContext } from "../../../components/PentestContext";
import { useEffect } from "react";
import OverviewTopWidget from "./components/OverviewTopWidget";
import { Card, Title } from "@tremor/react";
import { BasicInfoWidget } from "@/components/BasicInfoWidget";
import TopFiveCriticalDataWidget from "./components/TopFiveCriticalDataWidget";
import { portsData, technologiesData } from "../components/ReconnaissanceDummyData";
import { Cpu, EthernetPort, Network } from "lucide-react";
import { BasicInfoWidgetData } from "./page";

export default function OverviewMainTemplate({ pentestIdName }: { pentestIdName: string; }) {
    const [pentestId, pentestNameInUrl] = pentestIdName.split("_");
    const pentestName = pentestNameInUrl.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    const { pentestData, loading, error, setPentestId } = usePentestContext();

    useEffect(() => {
        if (typeof pentestId === 'string') {
            setPentestId(pentestId);
        }
    }, [pentestId]);

    if (error) return <div>{error}</div>;
    if (!pentestData && !loading) return <div></div>;
    if (loading || !pentestData) return <GlobalLoader />;

    const nmap: string = pentestData?.scanData.nmap ?? "";
    const whatWeb: string = pentestData?.scanData.whatweb ?? "";
    const amass: Array<string> = pentestData.scanData && pentestData.scanData.amass ? [...pentestData.scanData.amass] : [];

    console.log("Nmap Data from DB: ", nmap);
    console.log("WhatWeb Data from DB: ", whatWeb);
    const parseWhatWebOutput = (whatWebOutput: string) => {
        const sections = whatWebOutput.split(/WhatWeb report for /).filter(Boolean);
        const results: Record<string, string | Array<string>>[] = [];

        sections.forEach(section => {
            const lines = section.split('\n');
            const result: Record<string, string | Array<string>> = {};

            // URL
            result.url = lines[0].trim();

            // Key-value fields (Status, Title, IP, Country)
            lines.forEach(line => {
                if (line.startsWith('Status')) result.status = line.split(':')[1]?.trim();
                if (line.startsWith('Title')) result.title = line.split(':')[1]?.trim();
                if (line.startsWith('IP')) result.ip = line.split(':')[1]?.trim();
                if (line.startsWith('Country')) result.country = line.split(':')[1]?.trim();
                if (line.startsWith('Summary')) result.summary = line.split(':')[1]?.trim();
            });

            // Detected plugins
            const pluginSection = section.match(/Detected Plugins:\n([\s\S]*?)\nHTTP Headers:/);
            if (pluginSection) {
                const pluginsRaw = pluginSection[1];
                const pluginNames = [...pluginsRaw.matchAll(/\[ ([^\]]+) \]/g)].map(m => m[1]);
                result.plugins = pluginNames;
            }

            // HTTP headers
            const headersMatch = section.match(/HTTP Headers:\n([\s\S]*?)\nhttps?:\/\//);
            if (headersMatch) {
                const rawHeaders = headersMatch[1].trim().split('\n').map(line => line.trim());
                result.headers = rawHeaders;
            }

            results.push(result);
        });

        return results;
    }
    const whatWebOutput = whatWeb.replace(/\u001b\[[0-9;]*m/g, '');
    const parsedWhatWebData = parseWhatWebOutput(whatWebOutput);
    console.log("Parsed WhatWeb Data: ", parsedWhatWebData);

    const parseNmapOutput = (nmapOutput: string) => {
        const lines = nmapOutput.trim().split('\n');
        const result: {
            target: string | null;
            ip: string | null;
            scanTime: string | null;
            hostStatus: string | null;
            latency: string | null;
            filteredPorts: number | null;
            openPorts: Array<{ port: number; state: string; service: string; }>;
        } = {
            target: null,
            ip: null,
            scanTime: null,
            hostStatus: null,
            latency: null,
            filteredPorts: null,
            openPorts: []
        };

        for (const line of lines) {
            if (line.startsWith("Starting Nmap")) {
                const match = line.match(/Starting Nmap .* at (.+)/);
                if (match) result.scanTime = match[1].trim();
            }

            if (line.startsWith("Nmap scan report for")) {
                const match = line.match(/Nmap scan report for (.+) \(([\d.]+)\)/);
                if (match) {
                    result.target = match[1];
                    result.ip = match[2];
                }
            }

            if (line.includes("Host is up")) {
                const match = line.match(/Host is up \(([\d.s]+) latency\)/);
                result.hostStatus = "up";
                result.latency = match ? match[1] : null;
            }

            if (line.includes("filtered tcp ports")) {
                const match = line.match(/Not shown: (\d+) filtered tcp ports/);
                result.filteredPorts = match ? parseInt(match[1], 10) : null;
            }

            const portMatch = line.match(/^(\d+)\/tcp\s+(\w+)\s+(\w+)/);
            if (portMatch) {
                result.openPorts.push({
                    port: parseInt(portMatch[1], 10),
                    state: portMatch[2],
                    service: portMatch[3]
                });
            }
        }

        return result;
    }
    const parsedNmapData = parseNmapOutput(nmap);
    console.log("Parsed Nmap Data: ", parsedNmapData);

    let subdomains: Array<string> = [];
    amass.forEach((entry) => {
        const fqdnMatch = entry.match(
            /^(.+?) \(FQDN\) --> (.+?) --> (.+?) \(([^)]+)\)$/
        );
        if (fqdnMatch) {
            const relation = fqdnMatch[2].trim();
            const target = fqdnMatch[3].trim();

            if (relation === "node") subdomains.push(target);
        }
    });


    const whatWebData = technologiesData[technologiesData.length - 1];

    const basicInfoWidgetData: BasicInfoWidgetData[] = [
        {
            name: "URL/Domain",
            value: whatWebData.url,
        },
        {
            name: "Title",
            value: whatWebData.title,
        },
        {
            name: "IP Address",
            value: whatWebData.ip,
        },
        {
            name: "Status",
            value: whatWebData.status,
        },
        {
            name: "Country",
            value: whatWebData.country,
        }
    ];

    // const subDomains = aMassData.subdomains
    //     .filter((item) => item && item.trim() !== "")
    //     .map((item) => item.split(" --> ")[2].split(" ")[0].trim());

    const overviewTopWidgetData = [
        {
            title: "Sub Domains Discovered",
            value: subdomains.length,
            Icon: Network
        },
        {
            title: "Open Ports Discovered",
            value: portsData.ports.length,
            Icon: EthernetPort
        },
        {
            title: "Technologies Identified",
            value: whatWebData.summary.length,
            Icon: Cpu
        }
    ];

    const ports = portsData.ports.map(eachPorts => eachPorts.port);
    const technologies = whatWebData.summary.split(", ");

    return (
        <>
            <div className="flex flex-col gap-3">
                <OverviewTopWidget overviewTopWidgetData={overviewTopWidgetData} />
                <Card className="flex flex-col gap-3 p-4 rounded-md">
                    <Title className="font-bold text-widget-title text-widgetHeader">Basic Information</Title>
                    <BasicInfoWidget items={basicInfoWidgetData} columns={3} useDefault={false} />
                </Card>
                <TopFiveCriticalDataWidget subDomains={subdomains} ports={ports} technologies={technologies} />
            </div>
        </>
    )
}