"use client";

import { useEffect, useState } from "react";
import GlobalLoader from "@/components/GlobalLoader";
import { usePentestContext } from "../../../components/PentestContext";

// AI Report components
import SubdomainReport from "./SubdomainReport";
import NetMapReport from "./NetMapReport";
import ReconnaissanceTopWidget from "../ReconnaissanceTopWidget";
import { Cpu, EthernetPort, Network } from "lucide-react";

interface ScanResult {
    source: string;
    data: any;
}

function parseJson(block: string) {
    try {
        return JSON.parse(block.replace(/```json\n?|```/g, "").trim());
    } catch {
        return {};
    }
}

const fetchAIReportData = async (
    pentestData: Record<string, any>
): Promise<ScanResult[]> => {
    const scanData = pentestData?.scanData ?? {};

    const sources: { key: keyof typeof scanData; source: string }[] = [
        { key: "amass", source: "amass" },
    ];

    console.log("AI Report generation started...");

    const fetchPromises = sources.map(async ({ key, source }) => {
        const payload = {
            scanData: scanData[key] || {},
            source,
            userId: "default",
        };

        const res = await fetch(
            "https://ikoncloud-uat.keross.com/cstools/AiReport",
            {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            }
        );

        if (!res.ok) {
            console.error(`Error from ${source}:`, res.statusText);
            throw new Error(`HTTP ${res.status} on ${source}`);
        }

        const data = await res.json();
        console.log("Data came from Report scan: ", data);
        const parsedData = parseJson(data.summary);
        return parsedData;
    });

    const results = await Promise.all(fetchPromises);
    return results;
};

export default function FetchAIReportData({
    pentestIdName,
}: {
    pentestIdName: string;
}) {
    const [pentestId] = pentestIdName.split("_");
    const { pentestData, loading, error, setPentestId } = usePentestContext();

    const [reconLoading, setReconLoading] = useState(false);
    const [reconError, setReconError] = useState<string | null>(null);
    const [reconData, setReconData] = useState({});
    const [reconData_Domain, setReconData_Domain] = useState({});
    const [reconData_Netmap, setReconData_Netmap] = useState({});
    const [uniqueFQDN, setUniqueFQDN] = useState({});
    const [uniqueIP, setUniqueIP] = useState({});
    const [totlASN, setTotlASN] = useState({});
    const [cardData, setcardData] = useState({});

    useEffect(() => {
        if (pentestId) setPentestId(pentestId);
    }, [pentestId, setPentestId]);

    const handleReconClick = async () => {
        if (reconLoading || reconData_Domain.length) return;

        if (!pentestData) {
            setReconError("No pentest data available");
            return;
        }

        setReconLoading(true);
        setReconError(null);

        try {
            const results = await fetchAIReportData(pentestData);
            setReconData(results[0]);

            var totalUniqueFQDN = results[0]?.executive_summary?.unique_fqdns_count || 0;
            var totalUniqueIp = results[0]?.executive_summary?.unique_ips_count || 0;
            var totalUniqueASN = results[0]?.executive_summary?.unique_asns_count || 0;
            setUniqueFQDN(totalUniqueFQDN)
            setUniqueIP(totalUniqueIp)
            setTotlASN(totalUniqueASN)
            const reconnaissanceTopWidgetData = [
                {
                    title: "Total FDQN Identified",
                    value: uniqueFQDN,
                    Icon: Network
                },
                {
                    title: "Unique IP Addresses",
                    value: uniqueIP,
                    Icon: EthernetPort
                },
                {
                    title: "Key ASNs Involved",
                    value: totlASN,
                    Icon: Cpu
                }
            ];

            const allDomains = results[0]?.domains || [];
            const allNetworks = results[0]?.infrastructure || [];
            setReconData_Domain(allDomains);
            setReconData_Netmap(allNetworks);
            setcardData(reconnaissanceTopWidgetData);

        } catch (err: any) {
            setReconError(err.message || "Unknown error");
        } finally {
            setReconLoading(false);
        }
    };

    if (loading) return <GlobalLoader />;
    if (error)
        return <div className="p-6 text-red-600">Error: {error}</div>;
    if (!pentestData)
        return (
            <div> No data found...</div>
        );

    return (
        <>
            <div className="text-lg font-semibold px-6" onClick={handleReconClick}>Hello</div>
            {reconLoading && (
                <div className="p-6 text-center">Loading AI analysis...</div>
            )}

            {/* <ReconnaissanceTopWidget reconnaissanceTopWidgetData={cardData} /> */}

            {!reconLoading && !reconError && reconData_Domain.length > 0 && (
                <div className="space-y-6">
                    <SubdomainReport
                        domains={reconData_Domain.map(
                            ([fqdn, ipAddress, category, notesOrAsnHint]) => ({
                                fqdn,
                                ipAddress,
                                category,
                                notes: notesOrAsnHint,
                            })
                        )}
                    />

                    <NetMapReport
                        domains={reconData_Netmap.map(
                            ([netblock, asn, asn_name, hosting]) => ({
                                netblock,
                                asn,
                                asn_name,
                                hosting,
                            })
                        )}
                    />
                </div>
            )}

        </>
    );
}
