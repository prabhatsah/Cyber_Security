"use client";

import { useEffect, useState } from "react";
import GlobalLoader from "@/components/GlobalLoader";
import { usePentestContext } from "../../../components/PentestContext";

// AI Report components
import SubdomainReport from "./SubdomainReport";
import NetMapReport from "./NetMapReport";
import MailReport from "./MailReport";
import ReconnaissanceTopWidget from "../ReconnaissanceTopWidget";
import { Cpu, EthernetPort, Network } from "lucide-react";

interface ScanResult {
    source: string;
    data: any;
}

function parseJson(block: string) {
    try {
        return JSON.parse(block.replace(/```json\n?|```/g, "").trim());
    } catch {
        return {};
    }
}

const fetchAIReportData = async (
    pentestData: Record<string, any>
): Promise<ScanResult[]> => {
    const scanData = pentestData?.scanData ?? {};

    const sources: { key: keyof typeof scanData; source: string }[] = [
        { key: "amass", source: "amass" },
    ];

    console.log("AI Report generation started...");

    const fetchPromises = sources.map(async ({ key, source }) => {
        const payload = {
            scanData: scanData[key] || {},
            source,
            userId: "default",
        };

        const res = await fetch(
            "https://ikoncloud-uat.keross.com/cstools/AiReport",
            {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            }
        );

        if (!res.ok) {
            console.error(`Error from ${source}:`, res.statusText);
            throw new Error(`HTTP ${res.status} on ${source}`);
        }

        const data = await res.json();
        console.log("Data came from Report scan: ", data);
        const parsedData = parseJson(data.summary);
        return parsedData;
    });

    const results = await Promise.all(fetchPromises);
    return results;
};

export default function FetchAIReportData({
    pentestIdName, reconData
}: {
    pentestIdName: string;
}) {
    const [pentestId] = pentestIdName.split("_");
    const { pentestData, loading, error, setPentestId } = usePentestContext();
    console.log(reconData);

    const [reconLoading, setReconLoading] = useState(false);
    const [reconError, setReconError] = useState<string | null>(null);
    // const [reconData, setReconData] = useState();
    const [reconData_Domain, setReconData_Domain] = useState({});
    const [reconData_Netmap, setReconData_Netmap] = useState({});
    const [cardData, setcardData] = useState({});
    const [cardDescription, setcardDescription] = useState();
    const [domainDescription, setdomainDescription] = useState();
    const [networkDescription, setnetworkDescription] = useState();
    const [mailMXRecord, setmailMXRecord] = useState();
    const [nsRecord, setnsRecord] = useState();
    const [cNameRecord, setcNameRecord] = useState();
    const [mailMXRecordDescription, setMXDescription] = useState();
    const [nsRecordDescription, setNSDescription] = useState();
    const [cNameRecordDescription, setCNameDescription] = useState();


    useEffect(() => {
        if (pentestId) setPentestId(pentestId);
    }, [pentestId, setPentestId]);

    useEffect(() => {
        const fetchData = () => {
            setReconLoading(true);
            setReconError(null);

            try {
                const results = reconData;
                const report = results;
                // setReconData(report);

                const {
                    executive_summary: { unique_fqdns_count = 0, unique_ips_count = 0, unique_asns_count = 0 } = {},
                    executive_summary_info = "",
                    domains_info = "",
                    domains = [],
                    infrastructure = [],
                    infrastructure_info = "",
                    mx_records = [],
                    mx_records_info = "",
                    name_servers = [],
                    name_servers_info = "",
                    cname_chains = [],
                    cname_chains_info = "",

                } = report;

                setcardDescription(executive_summary_info);
                setdomainDescription(domains_info);
                setnetworkDescription(infrastructure_info);
                setmailMXRecord(mx_records)
                setnsRecord(name_servers)
                setcNameRecord(cname_chains)
                setMXDescription(mx_records_info)
                setNSDescription(name_servers_info)
                setCNameDescription(cname_chains_info)

                setcardData([
                    { title: "Total FQDN Identified", value: unique_fqdns_count, Icon: Network },
                    { title: "Unique IP Addresses", value: unique_ips_count, Icon: EthernetPort },
                    { title: "Key ASNs Involved", value: unique_asns_count, Icon: Cpu },
                ]);

                setReconData_Domain(domains);
                setReconData_Netmap(infrastructure);
            }
            catch (err: any) {
                setReconError(err.message || "Unknown error");
            }
            finally {
                setReconLoading(false);
            }
        };

        if (reconData) {
            fetchData();
        }
    }, [reconData]);


    // const handleReconClick = async () => {
    //     if (reconLoading || reconData_Domain.length) return;

    //     if (!pentestData) {
    //         setReconError("No pentest data available");
    //         return;
    //     }

    //     setReconLoading(true);
    //     setReconError(null);

    //     try {
    //         // const results = await fetchAIReportData(pentestData);
    //         // setReconData(results[0]);
    //         { loading && <div className="p-6 text-center">Loading AI Report Generator...</div> }
    //         { error && <div className="p-6 text-red-600">Error: {error}</div> }


    //         var totalUniqueFQDN = reconData?.executive_summary?.unique_fqdns_count || 0;
    //         var totalUniqueIp = reconData?.executive_summary?.unique_ips_count || 0;
    //         var totalUniqueASN = reconData?.executive_summary?.unique_asns_count || 0;
    //         var topDescription = reconData?.executive_summary_info || "";
    //         // setUniqueFQDN(totalUniqueFQDN)
    //         // setUniqueIP(totalUniqueIp)
    //         // setTotlASN(totalUniqueASN)
    //         setcardDescription(topDescription);
    //         const reconnaissanceTopWidgetData = [
    //             {
    //                 title: "Total FDQN Identified",
    //                 value: totalUniqueFQDN,
    //                 Icon: Network
    //             },
    //             {
    //                 title: "Unique IP Addresses",
    //                 value: totalUniqueIp,
    //                 Icon: EthernetPort
    //             },
    //             {
    //                 title: "Key ASNs Involved",
    //                 value: totalUniqueASN,
    //                 Icon: Cpu
    //             }
    //         ];

    //         const allDomains = results[0]?.domains || [];
    //         const allNetworks = results[0]?.infrastructure || [];
    //         setReconData_Domain(allDomains);
    //         setReconData_Netmap(allNetworks);
    //         setcardData(reconnaissanceTopWidgetData);

    //     } catch (err: any) {
    //         setReconError(err.message || "Unknown error");
    //     } finally {
    //         setReconLoading(false);
    //     }
    // };

    if (loading) return <GlobalLoader />;
    if (error)
        return <div className="p-6 text-red-600">Error: {error}</div>;
    if (!pentestData)
        return (
            <div> No data found...</div>
        );

    return (
        <>
            {/* <div className="text-lg font-semibold px-6" onClick={handleReconClick}>Hello</div> */}
            {reconLoading && (
                <div className="p-6 text-center">Loading AI analysis...</div>
            )}

            <ReconnaissanceTopWidget reconnaissanceTopWidgetData={cardData} cardDescription={cardDescription} />

            {!reconLoading && !reconError && reconData_Domain.length > 0 && (
                <div className="space-y-6">
                    <SubdomainReport
                        domains={reconData_Domain.map(
                            ([fqdn, ipAddress, category, notesOrAsnHint]) => ({
                                fqdn,
                                ipAddress,
                                category,
                                notes: notesOrAsnHint,
                            })
                        )}
                        domainDescription={domainDescription} 
                    />


                    <NetMapReport
                        networks={reconData_Netmap.map(
                            ([netblock, asn, asn_name, hosting]) => ({
                                netblock,
                                asn,
                                asn_name,
                                hosting,
                            })
                        )}
                        networkDescription = {networkDescription}
                    />

                    <MailReport mailMXRecord = {mailMXRecord} nsRecord = {nsRecord} cNameRecord = {cNameRecord} mailMXRecordDescription = {mailMXRecordDescription} nsRecordDescription = {nsRecordDescription} cNameRecordDescription = {cNameRecordDescription}/>
                </div>
            )}

        </>
    );
}
