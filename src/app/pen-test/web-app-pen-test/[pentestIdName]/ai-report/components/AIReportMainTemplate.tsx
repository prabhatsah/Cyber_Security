"use client";

import { useEffect, useState, useRef } from "react";
import html2canvas from "html2canvas";
import { usePentestContext } from "../../components/PentestContext";
import { useScanNotification } from "@/contexts/ScanNotificationContext";
import NoScanConfiguredTemplate from "../../components/NoScanConfiguredTemplate";
import AIReportDashboard from "./AIReportDashboard";
import { PDFReport } from "../../components/ai-report-download/PDFReport";
import { pdf } from "@react-pdf/renderer";
import { toast } from "@/lib/toast";
import GlobalLoader from "@/components/GlobalLoader";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import FetchAIReportData from "./ai-report-reconnaissance";
import * as api from "@/utils/api";

import { Cpu, EthernetPort, Network } from "lucide-react";

const reportData = [
  { metric: "Visitors", value: "1200" },
  { metric: "Bounce Rate", value: "43%" },
  { metric: "Conversion", value: "5.1%" },
];

import ReconnaissanceTopWidget from "./ReconnaissanceTopWidget";
import HostStatusCard from "./ai-report-reconnaissance/HostStatusCard";
import PortSummaryCard from "./ai-report-reconnaissance/PortSummaryCard";
import SubdomainReport from "./ai-report-reconnaissance/SubdomainReport";
import SecurityPostureCard from "./ai-report-reconnaissance/SecurityPostureCard";
import SoftwareVersionsCard from "./ai-report-reconnaissance/SoftwareVersionsCard";
import WhatwebReport from "./ai-report-reconnaissance/whatwebReport/components/WhatwebReport";
import DetailedPortsCard from "./ai-report-reconnaissance/DetailedPortsCard";
export default function AIReportMainTemplate({
  pentestIdName,
}: {
  pentestIdName: string;
}) {
  const [pentestId] = pentestIdName.split("_");
  const [pdfGenerated, setPdfGenerated] = useState<string | null>(null);

  const { pentestData, loading, error, setPentestId } = usePentestContext();

  const [reconLoading, setReconLoading] = useState(false);
  const [reconError, setReconError] = useState<string | null>(null);
  const [reconData, setReconData] = useState<Record<string, any> | undefined>();

  const hasFetchedRef = useRef(false);

  useEffect(() => {
    if (typeof pentestId === "string") {
      setPentestId(pentestId);
    }

  }, [pentestId]);

  // -----------------------------------------------------------------------------
  const fetchAIReportData = async (pentestData: Record<string, any>): Promise<Record<string, any>> => {
    const scanData = pentestData?.scanData ?? {};

    // Instead of firing three independent fetches, group the three sources into one call:
    const payload = {
      scanData,
      sources: ["amass", "nmap", "whatweb"],
      userId: "default",
    };

    const res = await fetch("https://ikoncloud-uat.keross.com/cstools/AiReport", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();
    console.log("Data came from AI scan: ", data);
    if (data && data['amass'] && Object.keys(data['amass']).length >= 12) {
      const updateStatus = await api.updateColumnGeneralised(
        "penetration_testing_history",
        "ai_report",
        data,
        "pentestid",
        pentestId,
        true,
        "ai_report_data"
      );
      console.log("AI Report updated in database: ", updateStatus);
    }

    var tempDbData = {
      "basicDetails" : pentestData.basicDetails,
      "scanData": pentestData.scanData,
      "isDataUpdated": false
    }

    if (pentestData && tempDbData) {
      const updateStatus = await api.updateColumnGeneralised(
        "penetration_testing_history",
        "data",
        tempDbData,
        "pentestid",
        pentestId,
        true,
        null
      );
      console.log("AI Report updated in database: ", updateStatus);
    }
    window.location.reload();

    return data;
  };

  useEffect(() => {
    if (!pentestData || hasFetchedRef.current) return;
    hasFetchedRef.current = true;

    const fetchData = async () => {
      setReconLoading(true);
      setReconError(null);
      try {
        var dbData = await api.fetchData(
          "penetration_testing_history",
          "id",
          [{ column: "pentestId", value: pentestId }],
          null,
          null //"ai_report"
        );
        // console.log(dbData)

        if (dbData.data && dbData.data[0] && dbData.data[0].ai_report && Object.keys(dbData.data[0].ai_report).length > 2) {
          // var lastScanDate = new Date(dbData.data[0].ai_report["whatweb"].scan_date_gmt);
          // const formatteScanDatadUTC = `${lastScanDate.getUTCFullYear()}-${String(lastScanDate.getUTCMonth() + 1).padStart(2, '0')}-${String(lastScanDate.getUTCDate()).padStart(2, '0')} ${String(lastScanDate.getUTCHours()).padStart(2, '0')}:${String(lastScanDate.getUTCMinutes()).padStart(2, '0')} UTC`;

          if (pentestData && pentestData.scanDataLastUpdatation){//if (new Date(dbData.data[0].ai_report["whatweb"].scan_date_gmt).toISOString().split('T')[0] !== new Date(pentestData.lastUpdated).toISOString().split('T')[0]) {
            console.log("AI Report data is not up to date, fetching new data...");
            const allReports = await fetchAIReportData(pentestData);
            setReconData(allReports);
          } else {
            console.log("AI Report data is up to date, using existing data...");
            setReconData(dbData.data?.[0]?.ai_report || {});
          }

        } else {
          const allReports = await fetchAIReportData(pentestData);
          setReconData(allReports);
        }

      } catch (err: any) {
        setReconError(err.message || "Unknown error");
      } finally {
        setReconLoading(false);
      }
    };

    fetchData();
  }, [pentestData]);


  if (loading) return <GlobalLoader />;
  if (error) return <div>{error}</div>;
  if (!pentestData) return <div>No data found.</div>;

  const zapData = pentestData.scanData.zap;

  const handleGenerateAndDownloadPDF = async () => {
    setPdfGenerated('in progress');

    const chartNode = document.getElementById("chart-to-export");

    if (!chartNode) {
      console.log("Chart element not found in DOM.");
      toast.push("Chart element not found in DOM!", "error");
      return;
    }

    const chartDivDarkModeClasses: Array<string> = [];
    chartNode.classList.forEach(eachClass => {
      eachClass.includes('dark:') ? chartDivDarkModeClasses.push(eachClass) : undefined;
    });

    chartDivDarkModeClasses.forEach(eachDarkModeClass => {
      chartNode.classList.remove(eachDarkModeClass);
    });

    try {
      const canvas = await html2canvas(chartNode, {
        scale: 2,
        backgroundColor: "#ffffff",
        useCORS: true,
      });

      const chartDataUrl = canvas.toDataURL("image/png");

      const doc = (
        <PDFReport
          data={reportData}
          chartImage={chartDataUrl}
          logoImage="/keross-logo-large.jpg"
        />
      );

      const blob = await pdf(doc).toBlob();

      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "React PDF using HTML2Canvas.pdf";
      link.click();

      chartDivDarkModeClasses.forEach(eachDarkModeClass => {
        chartNode.classList.add(eachDarkModeClass);
      });

      setPdfGenerated('completed');
    } catch (err) {
      console.error("Error generating PDF:", err);
      toast.push("Error generating PDF!", "error");
    }
  };

  let subdomains: Array<string> = [];

  return (
    // pdfGenerated === 'in progress' ? (
    //   <GlobalLoader />
    // ) : (
    <>
      {/* <div className="flex justify-end mb-4">
          <button onClick={handleGenerateAndDownloadPDF} className="px-4 py-2 bg-blue-600 text-white rounded">
            Generate & Download PDF
          </button>
        </div> */}
      <Accordion type="multiple" className="mt-3 ">

        <AccordionItem value="reconnaissance">
          <AccordionTrigger>
            Reconnaissance
          </AccordionTrigger>
          <AccordionContent className="px-6 flex flex-col gap-4">
            {(!reconData || !reconData.amass) ? (
              <GlobalLoader />
            ) : (
              <FetchAIReportData pentestIdName={pentestIdName} reconData={reconData} />
            )}


            {reconData && reconData["amass"] && reconData["nmap"] && (
              <HostStatusCard reconData={reconData["nmap"]} />
            )}
            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["port_summary"] && (
              <PortSummaryCard portData={reconData["nmap"]["port_summary"]} />
            )}
            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["recommendations"] && (
              <SecurityPostureCard
                firewallStatus="Active / Detected"
                recommendations={reconData["nmap"]["recommendations"] || {}}
              />
            )}

            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["open_ports"] && reconData["nmap"]["service_insights"] && (
              <DetailedPortsCard ports={reconData["nmap"]["open_ports"]} insights={reconData["nmap"]["service_insights"]} />
            )}

            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["software_versions"] && (
              <SoftwareVersionsCard versions={reconData["nmap"]["software_versions"]} />
            )}

            {reconData && reconData["amass"] && reconData["whatweb"] && (
              <WhatwebReport reconData={reconData["whatweb"]} />
            )}

          </AccordionContent>
        </AccordionItem>

      </Accordion>
      <Accordion type="multiple" className="mt-3 ">

        <AccordionItem value="vulnerability-Scan">
          <AccordionTrigger>
            Vulnerability
          </AccordionTrigger>
          <AccordionContent className="px-6">
            {zapData ? (
              <AIReportDashboard zapData={zapData} />
            ) : (
              <div className="h-full w-full overflow-auto mt-4">
                <NoScanConfiguredTemplate headerText="Vulnerability Scanning Not Configured Yet"
                  descriptionText="Initiate Scanning Vulnerabilities and View the Scan Results"
                />
              </div>
            )}

          </AccordionContent>
        </AccordionItem>

      </Accordion>

    </>
    // )
  );
}
