"use client";

import { useEffect, useState, useRef } from "react";
import html2canvas from "html2canvas";
import { usePentestContext } from "../../components/PentestContext";
import { useScanNotification } from "@/contexts/ScanNotificationContext";
import NoScanConfiguredTemplate from "../../components/NoScanConfiguredTemplate";
import AIReportDashboard from "./AIReportDashboard";
import { PDFReport } from "../../components/ai-report-download/PDFReport";
import { pdf } from "@react-pdf/renderer";
import { toast } from "@/lib/toast";
import GlobalLoader from "@/components/GlobalLoader";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import FetchAIReportData from "./ai-report-reconnaissance";
import * as api from "@/utils/api";

import { AlertTriangle, Cpu, EthernetPort, Eye, Globe, Mail, Network, Server } from "lucide-react";

const reportData = [
  { metric: "Visitors", value: "1200" },
  { metric: "Bounce Rate", value: "43%" },
  { metric: "Conversion", value: "5.1%" },
];

import ReconnaissanceTopWidget from "./ReconnaissanceTopWidget";
import HostStatusCard from "./ai-report-reconnaissance/HostStatusCard";
import PortSummaryCard from "./ai-report-reconnaissance/PortSummaryCard";
import SubdomainReport from "./ai-report-reconnaissance/SubdomainReport";
import SecurityPostureCard from "./ai-report-reconnaissance/SecurityPostureCard";
import SoftwareVersionsCard from "./ai-report-reconnaissance/SoftwareVersionsCard";
import WhatwebReport from "./ai-report-reconnaissance/whatwebReport/components/WhatwebReport";
import DetailedPortsCard from "./ai-report-reconnaissance/DetailedPortsCard";
import { MetricCard } from "./ai-report-reconnaissance/harvestorReport/MetricCard";
import { calculateRiskScore, getASNProviders, processHosts, processURLs, rawScanData } from "./ai-report-reconnaissance/harvestorReport/dataProcessor";
import { RiskMeter } from "./ai-report-reconnaissance/harvestorReport/RiskMeter";
import { NetworkMap } from "./ai-report-reconnaissance/harvestorReport/NetworkMap";
import { AttackSurface } from "./ai-report-reconnaissance/harvestorReport/AttackSurface";
import { DataTable } from "./ai-report-reconnaissance/harvestorReport/DataTable";
import KeyFindings from "./ai-report-reconnaissance/harvestorReport/KeyFindings";
import { Card } from "@tremor/react";
export default function AIReportMainTemplate({
  pentestIdName,
}: {
  pentestIdName: string;
}) {
  const [pentestId] = pentestIdName.split("_");
  const [pdfGenerated, setPdfGenerated] = useState<string | null>(null);

  const { pentestData, loading, error, setPentestId } = usePentestContext();

  const [reconLoading, setReconLoading] = useState(false);
  const [reconError, setReconError] = useState<string | null>(null);
  const [reconData, setReconData] = useState<Record<string, any> | undefined>();

  const hasFetchedRef = useRef(false);

  useEffect(() => {
    if (typeof pentestId === "string") {
      setPentestId(pentestId);
    }

  }, [pentestId]);

  // -----------------------------------------------------------------------------
  const fetchAIReportData = async (pentestData: Record<string, any>): Promise<Record<string, any>> => {
    const scanData = pentestData?.scanData ?? {};

    // Instead of firing three independent fetches, group the three sources into one call:
    const payload = {
      scanData,
      sources: ["amass", "nmap", "whatweb", "theHarvester"],
      userId: "default",
    };

    const res = await fetch("https://ikoncloud-uat.keross.com/cstools/AiReport", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();
    console.log("Data came from AI scan: ", data);
    if (data && data['amass'] && Object.keys(data['amass']).length >= 12) {
      const updateStatus = await api.updateColumnGeneralised(
        "penetration_testing_history",
        "ai_report",
        data,
        "pentestid",
        pentestId,
        true,
        "ai_report_data"
      );
      console.log("AI Report updated in database: ", updateStatus);
    }

    const fetchedDBData = await api.fetchData('penetration_testing_history', 'id', [{ column: 'pentestid', value: pentestId }], null);

    if (fetchedDBData && fetchedDBData.data && fetchedDBData.data.length > 0) {
      var dbData = fetchedDBData.data[0];
      if (dbData.data.isDataUpdated) {
        dbData.data.isDataUpdated = false;
      } else {
        dbData.data["isDataUpdated"] = false;
      }
    }

    if (pentestData && fetchedDBData.data[0].data) {
      const updateStatus = await api.updateColumnGeneralised(
        "penetration_testing_history",
        "data",
        fetchedDBData.data[0].data,
        "pentestid",
        pentestId,
        true,
        null
      );
    }
    window.location.reload();

    return data;
  };

  useEffect(() => {
    if (!pentestData || hasFetchedRef.current) return;
    hasFetchedRef.current = true;

    const fetchData = async () => {
      setReconLoading(true);
      setReconError(null);
      try {
        var dbData = await api.fetchData(
          "penetration_testing_history",
          "id",
          [{ column: "pentestId", value: pentestId }],
          null,
          "ai_report"
        );
        // console.log(dbData)

        if (dbData.data && dbData.data[0] && dbData.data[0].ai_report && Object.keys(dbData.data[0].ai_report).length > 2) {

          // if (pentestData && pentestData.scanDataLastUpdatation) {//if (new Date(dbData.data[0].ai_report["whatweb"].scan_date_gmt).toISOString().split('T')[0] !== new Date(pentestData.lastUpdated).toISOString().split('T')[0]) {
          //   console.log("AI Report data is not up to date, fetching new data...");
          //   const allReports = await fetchAIReportData(pentestData);
          //   setReconData(allReports);
          // } else {
          //   console.log("AI Report data is up to date, using existing data...");
          //   setReconData(dbData.data?.[0]?.ai_report || {});
          // }
          console.log("AI Report data is up to date, using existing data...");
          setReconData(dbData.data?.[0]?.ai_report || {});

        } else {
          const allReports = await fetchAIReportData(pentestData);
          setReconData(allReports);
        }

      } catch (err: any) {
        setReconError(err.message || "Unknown error");
      } finally {
        setReconLoading(false);
      }
    };

    fetchData();
  }, [pentestData]);


  if (loading) return <GlobalLoader />;
  if (error) return <div>{error}</div>;
  if (!pentestData) return <div>No data found.</div>;

  const zapData = pentestData.scanData.zap;

  const handleGenerateAndDownloadPDF = async () => {
    setPdfGenerated('in progress');

    const chartNode = document.getElementById("chart-to-export");

    if (!chartNode) {
      console.log("Chart element not found in DOM.");
      toast.push("Chart element not found in DOM!", "error");
      return;
    }

    const chartDivDarkModeClasses: Array<string> = [];
    chartNode.classList.forEach(eachClass => {
      eachClass.includes('dark:') ? chartDivDarkModeClasses.push(eachClass) : undefined;
    });

    chartDivDarkModeClasses.forEach(eachDarkModeClass => {
      chartNode.classList.remove(eachDarkModeClass);
    });

    try {
      const canvas = await html2canvas(chartNode, {
        scale: 2,
        backgroundColor: "#ffffff",
        useCORS: true,
      });

      const chartDataUrl = canvas.toDataURL("image/png");

      const doc = (
        <PDFReport
          data={reportData}
          chartImage={chartDataUrl}
          logoImage="/keross-logo-large.jpg"
        />
      );

      const blob = await pdf(doc).toBlob();

      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "React PDF using HTML2Canvas.pdf";
      link.click();

      chartDivDarkModeClasses.forEach(eachDarkModeClass => {
        chartNode.classList.add(eachDarkModeClass);
      });

      setPdfGenerated('completed');
    } catch (err) {
      console.error("Error generating PDF:", err);
      toast.push("Error generating PDF!", "error");
    }
  };

  let subdomains: Array<string> = [];

  const hosts = processHosts(rawScanData.hosts);
  const urls = processURLs(rawScanData.urls);
  const asnProviders = getASNProviders(rawScanData.asns);
  const riskScore = calculateRiskScore();

  const devEnvironments = hosts.filter(h => h.type === 'development').length;
  const loginPages = urls.filter(u => u.type === 'login').length;

  const hostColumns = [
    { key: 'hostname', label: 'Hostname', sortable: true },
    { key: 'ipAddress', label: 'IP Address', sortable: true },
    { key: 'environment', label: 'Environment', sortable: true },
    { key: 'riskLevel', label: 'Risk Level', sortable: true }
  ];

  const urlColumns = [
    { key: 'url', label: 'URL', sortable: true },
    { key: 'type', label: 'Type', sortable: true },
    { key: 'riskLevel', label: 'Risk Level', sortable: true }
  ];

  return (
    // pdfGenerated === 'in progress' ? (
    //   <GlobalLoader />
    // ) : (
    <>
      {/* <div className="flex justify-end mb-4">
          <button onClick={handleGenerateAndDownloadPDF} className="px-4 py-2 bg-blue-600 text-white rounded">
            Generate & Download PDF
          </button>
        </div> */}
      <Accordion type="multiple" className="mt-3 ">

        <AccordionItem value="reconnaissance">
          <AccordionTrigger>
            Reconnaissance
          </AccordionTrigger>
          <AccordionContent className="px-6 flex flex-col gap-4">
            {(!reconData || !reconData.amass) ? (
              <GlobalLoader />
            ) : (
              <FetchAIReportData pentestIdName={pentestIdName} reconData={reconData} />
            )}


            {reconData && reconData["amass"] && reconData["nmap"] && (
              <HostStatusCard reconData={reconData["nmap"]} />
            )}
            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["port_summary"] && (
              <PortSummaryCard portData={reconData["nmap"]["port_summary"]} />
            )}
            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["recommendations"] && (
              <SecurityPostureCard
                firewallStatus="Active / Detected"
                recommendations={reconData["nmap"]["recommendations"] || {}}
              />
            )}

            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["open_ports"] && reconData["nmap"]["service_insights"] && (
              <DetailedPortsCard ports={reconData["nmap"]["open_ports"]} insights={reconData["nmap"]["service_insights"]} />
            )}

            {reconData && reconData["amass"] && reconData["nmap"] && reconData["nmap"]["software_versions"] && (
              <SoftwareVersionsCard versions={reconData["nmap"]["software_versions"]} />
            )}

            {reconData && reconData["amass"] && reconData["whatweb"] && (
              <WhatwebReport reconData={reconData["whatweb"]} />
            )}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-2">
              <MetricCard
                title="Total Hosts"
                value={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["hosts"].length.toString() : "0"}
                icon={Server}
                riskLevel="medium"
              />
              <MetricCard
                title="IP Addresses"
                value={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["ips"].length.toString() : "0"}
                icon={Globe}
                riskLevel="low"
              />
              <MetricCard
                title="Exposed Emails"
                value={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["emails"].length.toString() : "0"}
                icon={Mail}
                riskLevel="medium"
              />
              <MetricCard
                title="Login Interfaces"
                value={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["urls"].filter((entry: any) => (entry.type).toLowerCase() == "login").length.toString() : "0"}
                icon={Eye}
                riskLevel="critical"
              />
            </div>
            {/* Risk Assessment & Network Map */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-2">
              <div className="lg:col-span-1">
                <RiskMeter score={riskScore} />
              </div>
              {reconData && reconData["amass"] && reconData["theHarvester"] && (
                <div className="lg:col-span-2">
                  <NetworkMap asns={reconData["theHarvester"]["asns"]} ipCount={reconData["theHarvester"]["ips"].length} />
                </div>
              )}

            </div>

            {/* Attack Surface Analysis */}
            <div className="mb-8">
              {reconData && reconData["amass"] && reconData["theHarvester"] && (
                <AttackSurface
                  devEnvironments={devEnvironments}
                  loginPages={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["urls"].filter((entry: any) => (entry.type).toLowerCase() == "login").length.toString() : "0"}
                  exposedEmails={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["emails"].length.toString() : "0"}
                  totalHosts={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["hosts"].length.toString() : "0"}
                  keyFindings={reconData && reconData["theHarvester"] ? reconData["theHarvester"]["keyFindings"] : []}
                />
              )}
            </div>

            {/* Data Tables */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-2">
              {reconData && reconData["amass"] && reconData["theHarvester"] && (
                <DataTable
                  title="Discovered Hosts"
                  data={reconData["theHarvester"]["hosts"]}
                  columns={hostColumns}
                />
              )}
              {reconData && reconData["amass"] && reconData["theHarvester"] && (
                <DataTable
                  title="Discovered URLs"
                  data={reconData["theHarvester"]["urls"]}
                  columns={urlColumns}
                />
              )}
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {reconData?.amass && reconData?.theHarvester?.emails && (
                <div className="  border  rounded-xl p-6 h-80">
                  <h3 className="text-lg font-semibold  mb-4">Email Intelligence</h3>
                  <div className="space-y-3 overflow-y-auto h-full pb-8">
                    {reconData.theHarvester.emails.map((email: string, idx: number) => (
                      <div key={idx} className="flex items-center gap-3 p-3 border rounded-lg">
                        <Mail className="h-4 w-4 text-cyan-400 flex-shrink-0" />
                        <span className=" font-mono text-sm break-all">{email}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              {reconData && reconData["amass"] && reconData["theHarvester"] && (
                <KeyFindings highPriorityFindings={reconData["theHarvester"]["highPriorityFindings"]} />
              )}
            </div>


          </AccordionContent>
        </AccordionItem>

      </Accordion>
      <Accordion type="multiple" className="mt-3 ">

        <AccordionItem value="vulnerability-Scan">
          <AccordionTrigger>
            Vulnerability
          </AccordionTrigger>
          <AccordionContent className="px-6">
            {zapData ? (
              <AIReportDashboard zapData={zapData} />
            ) : (
              <div className="h-full w-full overflow-auto mt-4">
                <NoScanConfiguredTemplate headerText="Vulnerability Scanning Not Configured Yet"
                  descriptionText="Initiate Scanning Vulnerabilities and View the Scan Results"
                />
              </div>
            )}

          </AccordionContent>
        </AccordionItem>

      </Accordion>

    </>
    // )
  );
}
